import os
from wrapt_timeout_decorator import *
from helpers import *
import json
import asyncio
import uuid
import pickle
from datetime import datetime, timedelta
from googleapiclient.errors import HttpError
from email.mime.text import MIMEText
from base64 import urlsafe_b64encode
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
import httpx
from sentence_transformers import SentenceTransformer, util
from helpers import *
from urllib.parse import quote
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv

load_dotenv("../.env")  # Load environment variables from .env file


def authenticate_service(api_name: str, api_version: str):
    """
    Authenticate and return the specified Google API service.

    This function attempts to load credentials from a token pickle file.
    If the file exists, it loads the credentials. Otherwise, authentication
    would typically need to be handled through an OAuth flow (not shown here but implied).

    Args:
        api_name (str): The name of the Google API (e.g., 'gmail', 'docs').
        api_version (str): The version of the Google API (e.g., 'v1', 'v3').

    Returns:
        googleapiclient.discovery.Resource: The authenticated Google API service resource.
    """
    creds = None

    if os.path.exists("../token.pickle"):
        with open("../token.pickle", "rb") as token:
            creds = pickle.load(token)

    return build(api_name, api_version, credentials=creds)


def authenticate_gmail():
    """
    Authenticate and return the Gmail API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Gmail API service resource.
    """
    return authenticate_service("gmail", "v1")


def authenticate_docs():
    """
    Authenticate and return the Google Docs API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Google Docs API service resource.
    """
    return authenticate_service("docs", "v1")


def authenticate_calendar():
    """
    Authenticate and return the Google Calendar API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Google Calendar API service resource.
    """
    return authenticate_service("calendar", "v3")


def authenticate_sheets():
    """
    Authenticate and return the Google Sheets API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Google Sheets API service resource.
    """
    return authenticate_service("sheets", "v4")


def authenticate_slides():
    """
    Authenticate and return the Google Slides API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Google Slides API service resource.
    """
    return authenticate_service("slides", "v1")


def authenticate_drive():
    """
    Authenticate and return the Google Drive API service.

    Returns:
        googleapiclient.discovery.Resource: Authenticated Google Drive API service resource.
    """
    return authenticate_service("drive", "v3")

async def create_message(to: str, subject: str, message: str) -> str:
    """
    Create a MIME message for an email and elaborate the message body using an external service.

    This function takes recipient, subject, and a message body, then calls an external
    'elaborator' service to potentially enhance or reformat the message. Finally, it constructs
    a MIMEText message ready to be sent via email.

    Args:
        to (str): Recipient email address.
        subject (str): Email subject.
        message (str): Email body text.

    Returns:
        str: Raw, URL-safe base64 encoded MIME message, ready to be sent via Gmail API.
             Raises an exception if there is an error during message creation or elaboration.
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:5001/elaborator",
                json={
                    "input": f"ELABORATE THIS EMAIL IN THE FIRST PERSON. USE THE NECESSARY SALUTATIONS.\n\nEMAIL SUBJECT: {subject}.\n\nEMAIL BODY: {message}",
                    "purpose": "Email",
                },
            )

            response_json = response.json()

            if response.status_code == 200:
                elaborated_message = response_json.get("message", message)
            else:
                elaborated_message = message
            
        print(f"Elaborated message: {elaborated_message}")
        print(type(elaborated_message))

        msg = MIMEText(
            elaborated_message
            + "\n\nThis email was sent via Sentient, a personal AI companion with agentic integrations and graph memory.\n\nLearn more at https://existence.technology/sentient\n\n Emails are generated by AI models and may not always be accurate or contextually relevant."
        )
        msg.add_header("To", to)
        msg.add_header("Subject", subject)

        raw = urlsafe_b64encode(msg.as_bytes()).decode()
        return raw
    except Exception as error:
        print(f"Error creating message: {str(error)}")
        raise Exception(f"Error creating message: {error}")

async def create_presentation(service, title: str) -> Dict[str, Any]:
    """
    Create a new Google Slides presentation.

    Args:
        service: Authenticated Google Slides API service.
        title (str): Title of the new presentation.

    Returns:
        Dict[str, Any]: The created presentation resource.
                         Raises an exception if there is an error during presentation creation.
    """
    try:
        presentation = service.presentations().create(body={"title": title}).execute()
        return presentation
    except HttpError as error:
        print(str(error))
        raise Exception(error)


async def create_slide(service, presentation_id: str, title: str, content: List[str]):
    """
    Create a slide in an existing Google Slides presentation and insert text into title and body.

    This function creates a new slide with 'TITLE_AND_BODY' layout, then finds or creates text boxes
    for the title and body, and inserts the provided title and content.

    Args:
        service: Authenticated Google Slides API service.
        presentation_id (str): ID of the presentation to add the slide to.
        title (str): Title text for the slide.
        content (List[str]): List of strings representing the content for the slide body.
                             Each string will be a new line in the body text box.

    Raises:
        Exception: If there's an error in creating or updating the slide.
    """
    try:
        requests = [
            {
                "createSlide": {
                    "slideLayoutReference": {"predefinedLayout": "TITLE_AND_BODY"}
                }
            }
        ]
        response = (
            service.presentations()
            .batchUpdate(presentationId=presentation_id, body={"requests": requests})
            .execute()
        )

        slide_id = response["replies"][0]["createSlide"]["objectId"]

        slide_objects = (
            service.presentations()
            .get(presentationId=presentation_id)
            .execute()["slides"]
        )
        title_box_id = None
        body_box_id = None

        for slide in slide_objects:
            if slide["objectId"] == slide_id:
                elements = slide.get("pageElements", [])
                for element in elements:
                    shape = element.get("shape")
                    if shape:
                        shape_type = shape.get("shapeType")
                        if shape_type == "TEXT_BOX":
                            if title_box_id == None:
                                title_box_id = element["objectId"]
                            else:
                                body_box_id = element["objectId"]
                break

        requests = []
        if title_box_id:
            requests.append(
                {
                    "insertText": {
                        "objectId": title_box_id,
                        "text": title,
                        "insertionIndex": 0,
                    }
                }
            )
        else:
            unique_title_id = f"TitleBox_{uuid.uuid4().hex}"
            requests.append(
                {
                    "createShape": {
                        "objectId": unique_title_id,
                        "shapeType": "TEXT_BOX",
                        "elementProperties": {
                            "pageObjectId": slide_id,
                            "size": {
                                "width": {"magnitude": 3000000, "unit": "EMU"},
                                "height": {"magnitude": 500000, "unit": "EMU"},
                            },
                            "transform": {
                                "scaleX": 1,
                                "scaleY": 1,
                                "translateX": 200000,
                                "translateY": 200000,
                                "unit": "EMU",
                            },
                        },
                    }
                }
            )
            requests.append(
                {
                    "insertText": {
                        "objectId": unique_title_id,
                        "text": title,
                        "insertionIndex": 0,
                    }
                }
            )

        if body_box_id:
            requests.append(
                {
                    "insertText": {
                        "objectId": body_box_id,
                        "text": "\n".join(content),
                        "insertionIndex": 0,
                    }
                }
            )
        else:
            unique_body_id = f"BodyBox_{uuid.uuid4().hex}"
            requests.append(
                {
                    "createShape": {
                        "objectId": unique_body_id,
                        "shapeType": "TEXT_BOX",
                        "elementProperties": {
                            "pageObjectId": slide_id,
                            "size": {
                                "width": {"magnitude": 4000000, "unit": "EMU"},
                                "height": {"magnitude": 2000000, "unit": "EMU"},
                            },
                            "transform": {
                                "scaleX": 1,
                                "scaleY": 1,
                                "translateX": 200000,
                                "translateY": 1000000,
                                "unit": "EMU",
                            },
                        },
                    }
                }
            )
            requests.append(
                {
                    "insertText": {
                        "objectId": unique_body_id,
                        "text": "\n".join(content),
                        "insertionIndex": 0,
                    }
                }
            )

        if requests:
            service.presentations().batchUpdate(
                presentationId=presentation_id, body={"requests": requests}
            ).execute()
        else:
            raise Exception(
                "No valid text placeholders found on the slide, and no text boxes created."
            )

    except HttpError as error:
        print(f"Error creating or updating slide: {str(error)}")
        raise Exception(f"Error creating or updating slide: {error}")


async def send_email(to: str, subject: str, body: str) -> Dict[str, Any]:
    """
    Send an email using the Gmail API.

    Args:
        to (str): Recipient email address.
        subject (str): Email subject.
        body (str): Email body text.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure.
                         Returns {"status": "success", "result": "Email sent successfully."} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        service = authenticate_gmail()
        message_body = {"raw": await create_message(to, subject, body)}
        service.users().messages().send(userId="me", body=message_body).execute()
        return {"status": "success", "result": "Email sent successfully."}
    except Exception as error:
        print(f"Error sending email: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def create_draft(to: str, subject: str, body: str) -> Dict[str, Any]:
    """
    Create a draft email using the Gmail API.

    Args:
        to (str): Recipient email address for the draft.
        subject (str): Email subject for the draft.
        body (str): Email body text for the draft.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure.
                         Returns {"status": "success", "result": f"Draft created successfully with ID: {draft['id']}"} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        service = authenticate_gmail()
        message_body = {"raw": await create_message(to, subject, body)}
        draft = (
            service.users()
            .drafts()
            .create(userId="me", body={"message": message_body})
            .execute()
        )
        return {
            "status": "success",
            "result": f"Draft created successfully with ID: {draft['id']}",
        }
    except Exception as error:
        print(f"Error creating email draft: {str(error)}")
        return {"status": "failure", "error": str(error)}


def search_inbox(query: str, **kwargs: Any) -> Dict[str, Any]:
    """
    Search the Gmail inbox for emails matching the query.

    This function searches the user's Gmail inbox for emails that match the given query.
    It retrieves up to 10 matching emails, extracts relevant information (id, subject, sender, snippet, body),
    and constructs a Gmail search URL for direct access in the browser.

    Args:
        query (str): The search query string (e.g., "from:sender@example.com subject:meeting").
        **kwargs (Any):  Arbitrary keyword arguments. Not used in this function but included for compatibility.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and search results.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Emails found successfully",
                                 "email_data": List[Dict], # List of email details
                                 "gmail_search_url": str # URL to view search results in Gmail
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_gmail()
        results = service.users().messages().list(userId="me", q=query).execute()
        messages = results.get("messages", [])
        email_data: List[Dict[str, Any]] = []
        for message in messages[:10]:
            msg = (
                service.users()
                .messages()
                .get(userId="me", id=message["id"], format="full")
                .execute()
            )

            headers = {
                h["name"]: h["value"] for h in msg.get("payload", {}).get("headers", [])
            }
            snippet = msg.get("snippet", "No preview available")
            email_body = extract_email_body(msg.get("payload", {}))

            email_data.append(
                {
                    "id": message["id"],
                    "subject": headers.get("Subject", "No Subject"),
                    "from": headers.get("From", "Unknown Sender"),
                    "snippet": snippet,
                    "body": email_body,
                }
            )

        gmail_search_url = f"https://mail.google.com/mail/u/0/#search/{quote(query)}"

        return {
            "status": "success",
            "result": {
                "response": "Emails found successfully",
                "email_data": email_data,
                "gmail_search_url": gmail_search_url,
            },
        }
    except Exception as error:
        print(f"Error searching inbox: {error}")
        return {"status": "failure", "error": str(error)}


async def find_best_matching_email(query: str) -> Dict[str, Any]:
    """
    Search Gmail inbox and find the best matching email ID based on semantic similarity.

    This function searches the user's inbox for recent emails, encodes email subjects and bodies
    using a sentence transformer model, and finds the email with the highest cosine similarity
    to the input query.

    Args:
        query (str): The query string to compare against email content.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and the best matching email details.
                         On success, returns:
                         {
                             "status": "success",
                             "email_id": str, # ID of the best matching email
                             "email_details": Dict # Details of the best matching email
                         }
                         On failure (no emails found or error during processing), returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_gmail()
        results = service.users().messages().list(userId="me", q="in:inbox").execute()
        messages = results.get("messages", [])

        if not messages:
            return {"status": "failure", "error": "No matching emails found."}

        email_data: List[Dict[str, Any]] = []
        for message in messages[:10]:
            msg = (
                service.users()
                .messages()
                .get(userId="me", id=message["id"], format="full")
                .execute()
            )

            headers = {
                h["name"]: h["value"] for h in msg.get("payload", {}).get("headers", [])
            }
            snippet = msg.get("snippet", "No preview available")
            email_body = extract_email_body(msg.get("payload", {}))

            email_data.append(
                {
                    "id": message["id"],
                    "subject": headers.get("Subject", "No Subject"),
                    "from": headers.get("From", "Unknown Sender"),
                    "snippet": snippet,
                    "body": email_body,
                }
            )

        model = SentenceTransformer("all-MiniLM-L6-v2")
        query_embedding = model.encode(query, convert_to_tensor=True)
        email_embeddings = model.encode(
            [e["subject"] + " " + e["body"] for e in email_data], convert_to_tensor=True
        )

        scores = util.pytorch_cos_sim(query_embedding, email_embeddings)[0]
        best_match_index = scores.argmax().item()

        best_email = email_data[best_match_index]
        return {
            "status": "success",
            "email_id": best_email["id"],
            "email_details": best_email,
        }

    except HttpError as error:
        return {"status": "failure", "error": f"Google API Error: {str(error)}"}
    except Exception as error:
        print(f"Error in finding best email: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def reply_email(query: str, body: str) -> Dict[str, Any]:
    """
    Reply to an existing email based on a query.

    This function finds the best matching email using `find_best_matching_email` and then sends
    a reply to the sender of that email with the provided body.

    Args:
        query (str): Query to find the email to reply to.
        body (str): Body of the reply email.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of the reply action.
                         Returns {"status": "success", "result": {"response": "Reply sent successfully."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        match = await find_best_matching_email(query)
        if match["status"] != "success":
            return {"status": "failure", "error": "No matching email found."}

        service = authenticate_gmail()

        to = match["email_details"]["from"]
        subject = match["email_details"]["subject"]

        reply_body = body

        message_body = {"raw": await create_message(to, subject, reply_body)}

        service.users().messages().send(userId="me", body=message_body).execute()
        return {"status": "success", "result": {"response": "Reply sent successfully."}}
    except Exception as error:
        print(f"Error in replying email: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def forward_email(query: str, to: str) -> Dict[str, Any]:
    """
    Forward an existing email based on a query to a specified recipient.

    This function finds the best matching email using `find_best_matching_email` and then forwards
    that email to the provided recipient email address.

    Args:
        query (str): Query to find the email to forward.
        to (str): Recipient email address for forwarding.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of the forward action.
                         Returns {"status": "success", "result": {"response": f"Email forwarded to {to} successfully."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        match = await find_best_matching_email(query)
        if match["status"] != "success":
            return {"status": "failure", "error": "No matching email found."}

        service = authenticate_gmail()
        subject = match["email_details"]["subject"]
        body = match["email_details"]["body"]
        message_body = {"raw": await create_message(to, subject, body)}
        service.users().messages().send(userId="me", body=message_body).execute()

        return {
            "status": "success",
            "result": {"response": f"Email forwarded to {to} successfully."},
        }
    except Exception as error:
        print(f"Error in forwarding email: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def delete_email(query: str) -> Dict[str, Any]:
    """
    Delete an email based on a query.

    This function finds the best matching email using `find_best_matching_email` and then deletes
    that email from the user's inbox.

    Args:
        query (str): Query to find the email to delete.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of the delete action.
                         Returns {"status": "success", "result": {"response": "Email deleted successfully."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        match = await find_best_matching_email(query)
        if match["status"] != "success":
            return {"status": "failure", "error": "No matching email found."}

        email_id = match["email_id"]
        service = authenticate_gmail()
        service.users().messages().delete(userId="me", id=email_id).execute()
        return {
            "status": "success",
            "result": {"response": "Email deleted successfully."},
        }
    except Exception as error:
        print(f"Error in deleting email: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def mark_email_as_read(query: str) -> Dict[str, Any]:
    """
    Mark an email as read based on a query.

    This function finds the best matching email using `find_best_matching_email` and then marks
    that email as read in the user's inbox.

    Args:
        query (str): Query to find the email to mark as read.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of marking as read.
                         Returns {"status": "success", "result": {"response": "Email marked as read."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        match = await find_best_matching_email(query)
        if match["status"] != "success":
            return {"status": "failure", "error": "No matching email found."}

        email_id = match["email_id"]
        service = authenticate_gmail()
        service.users().messages().modify(
            userId="me", id=email_id, body={"removeLabelIds": ["UNREAD"]}
        ).execute()
        return {"status": "success", "result": {"response": "Email marked as read."}}
    except Exception as error:
        print(f"Error in marking email as read: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def mark_email_as_unread(query: str) -> Dict[str, Any]:
    """
    Mark an email as unread based on a query.

    This function finds the best matching email using `find_best_matching_email` and then marks
    that email as unread in the user's inbox.

    Args:
        query (str): Query to find the email to mark as unread.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of marking as unread.
                         Returns {"status": "success", "result": {"response": "Email marked as unread."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        match = await find_best_matching_email(query)
        if match["status"] != "success":
            return {"status": "failure", "error": "No matching email found."}

        email_id = match["email_id"]
        service = authenticate_gmail()
        service.users().messages().modify(
            userId="me", id=email_id, body={"addLabelIds": ["UNREAD"]}
        ).execute()
        return {"status": "success", "result": {"response": "Email marked as unread."}}
    except Exception as error:
        print(f"Error in marking email as unread: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def delete_spam_emails(**kwargs: Any) -> Dict[str, Any]:
    """
    Delete all emails from the spam folder.

    This function retrieves all emails in the user's spam folder and deletes them.

    Args:
        **kwargs (Any): Arbitrary keyword arguments. Not used in this function but included for compatibility.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure of deleting spam emails.
                         Returns {"status": "success", "result": {"response": f"Deleted {len(messages)} spam messages."}} on success.
                         Returns {"status": "failure", "error": str(error)} on failure.
    """
    try:
        service = authenticate_gmail()
        results = service.users().messages().list(userId="me", q="in:spam").execute()
        messages = results.get("messages", [])

        if not messages:
            return {"status": "success", "result": "No spam messages found."}

        for message in messages:
            service.users().messages().delete(userId="me", id=message["id"]).execute()

        return {
            "status": "success",
            "result": {"response": f"Deleted {len(messages)} spam messages."},
        }

    except Exception as error:
        print(f"Error in deleting spam emails: {str(error)}")
        return {"status": "failure", "error": str(error)}


async def elaborate_text(input_text: str) -> str:
    """
    Call the /elaborator endpoint to elaborate the input text.

    This function sends a POST request to an external 'elaborator' service to enhance or reformat
    the given input text, intended for document content.

    Args:
        input_text (str): The text to be elaborated.

    Returns:
        str: The elaborated text returned by the service, or the original text if elaboration fails.
    """
    try:
        async with httpx.AsyncClient(timeout=None) as client:
            response = await client.post(
                "http://localhost:5001/elaborator",
                json={"input": input_text, "purpose": "Document"},
            )
            if response.status_code == 200:
                return response.json().get("message", input_text)
            else:
                return input_text
    except Exception as e:
        print(f"Error during elaboration: {str(e)}")
        return input_text


async def create_document(service, title: str) -> str:
    """
    Create a new Google Doc with a specified title and return its document ID.

    Args:
        service: Authenticated Google Docs API service.
        title (str): Title of the new document.

    Returns:
        str: The ID of the newly created Google Document.
             Raises an exception if there is an error during document creation.
    """
    try:
        document = service.documents().create(body={"title": title}).execute()
        print(f"Created document with title: {document['title']}")
        return document["documentId"]
    except HttpError as error:
        print(f"An error occurred while creating the document: {error}")
        raise


async def update_document(service, document_id: str, text: str) -> Dict[str, Any]:
    """
    Update the Google Doc by adding elaborated text at the beginning of the document.

    Args:
        service: Authenticated Google Docs API service.
        document_id (str): ID of the document to update.
        text (str): The text to insert into the document.

    Returns:
        Dict[str, Any]: The result of the batch update operation from the Google Docs API.
                         Raises an exception if there is an error during document update.
    """
    try:
        requests = [
            {
                "insertText": {
                    "location": {
                        "index": 1,
                    },
                    "text": text,
                }
            }
        ]
        result = (
            service.documents()
            .batchUpdate(documentId=document_id, body={"requests": requests})
            .execute()
        )
        return result
    except HttpError as error:
        print(f"An error occurred while updating the document: {error}")
        raise


async def add_event(
    start: str,
    end: str,
    timezone: str,
    attendees: Optional[List[str]] = None,
    description: Optional[str] = None,
    summary: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Add an event to Google Calendar.

    Args:
        start (str): Start datetime of the event in ISO format (e.g., '2023-10-27T10:00:00-07:00').
        end (str): End datetime of the event in ISO format (e.g., '2023-10-27T11:00:00-07:00').
        timezone (str): Timezone for the event (e.g., 'America/Los_Angeles').
        attendees (Optional[List[str]]): List of attendee email addresses (optional).
        description (Optional[str]): Event description (optional).
        summary (Optional[str]): Event summary or title (optional, defaults to 'No Title').

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and event details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Event created successfully",
                                 "event_id": str # URL to the created event in Google Calendar
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_calendar()
        event = {
            "summary": summary or "No Title",
            "description": description or "",
            "start": {
                "dateTime": start,
                "timeZone": timezone,
            },
            "end": {
                "dateTime": end,
                "timeZone": timezone,
            },
            "attendees": [{"email": email} for email in attendees] if attendees else [],
        }
        created_event = (
            service.events().insert(calendarId="primary", body=event).execute()
        )
        return {
            "status": "success",
            "result": {
                "response": "Event created successfully",
                "event_id": created_event.get("htmlLink"),
            },
        }
    except HttpError as error:
        print(f"Error adding event: {error}")
        return {"status": "failure", "error": str(error)}


async def search_events(query: str) -> Dict[str, Any]:
    """
    Search for events in Google Calendar based on a query.

    Args:
        query (str): Query string to search for in event titles and descriptions.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and event search results.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Events found successfully",
                                 "events": List[Dict] # List of event resources
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_calendar()
        now = datetime.utcnow().isoformat() + "Z"
        events_result = (
            service.events()
            .list(
                calendarId="primary",
                q=query,
                timeMin=now,
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        events = events_result.get("items", [])
        return {
            "status": "success",
            "result": {"response": "Events found successfully", "events": events},
        }
    except HttpError as error:
        print(f"Error searching events: {error}")
        return {"status": "failure", "error": str(error)}


async def list_upcoming_events(days: int = 7) -> Dict[str, Any]:
    """
    List upcoming events for the next n days.

    Args:
        days (int): Number of days to look ahead for upcoming events (default is 7).

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and upcoming events.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Upcoming events found successfully",
                                 "events": List[Dict] # List of event resources
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_calendar()
        now = datetime.utcnow().isoformat() + "Z"
        max_time = (datetime.utcnow() + timedelta(days=days)).isoformat() + "Z"
        events_result = (
            service.events()
            .list(
                calendarId="primary",
                timeMin=now,
                timeMax=max_time,
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        events = events_result.get("items", [])
        return {
            "status": "success",
            "result": {
                "response": "Upcoming events found successfully",
                "events": events,
            },
        }
    except HttpError as error:
        print(f"Error listing upcoming events: {error}")
        return {"status": "failure", "error": str(error)}


async def search_file_in_gdrive(query: str) -> Dict[str, Any]:
    """
    Search for files in Google Drive matching the query and return their URLs.

    Args:
        query (str): Query string to search for files by name in Google Drive.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and file search results.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "File search successful",
                                 "files": List[Dict] # List of file details with name and URL
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_drive()
        results = (
            service.files()
            .list(q=f"name contains '{query}'", fields="files(id, name)")
            .execute()
        )
        files = results.get("files", [])

        file_urls: List[Dict[str, str]] = [
            {
                "name": file["name"],
                "url": f"https://drive.google.com/file/d/{file['id']}/view",
            }
            for file in files
        ]

        return {
            "status": "success",
            "result": {"response": "File search successful", "files": file_urls},
        }
    except HttpError as error:
        print(f"Error searching files: {error}")
        return {"status": "failure", "error": str(error)}


async def search_folder(service, folder_name: str) -> str:
    """
    Search for a folder in Google Drive by name and return its folder ID.

    Args:
        service: Authenticated Google Drive API service.
        folder_name (str): Name of the folder to search for.

    Returns:
        str: The ID of the folder if found.
             Raises an exception if no folder is found or if there's an error during search.
    """
    try:
        query = f"name = '{folder_name}' and mimeType = 'application/vnd.google-apps.folder'"
        results = service.files().list(q=query, fields="files(id, name)").execute()
        folders = results.get("files", [])
        if not folders:
            raise Exception(f"No folder found with the name '{folder_name}'.")
        return folders[0]["id"]
    except Exception as e:
        raise Exception(f"Error searching for folder: {e}")


async def create_google_doc(
    text: str, title: str = "Untitled Document"
) -> Dict[str, Any]:
    """
    Create a Google Document and return its URL in the response.

    This function creates a new Google Doc with the given title, elaborates the provided text,
    and updates the document with the elaborated text.

    Args:
        text (str): The text content to be added to the document.
        title (str): Title of the new Google Document (default is "Untitled Document").

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and document details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Document created successfully",
                                 "url": str # URL to the created Google Document
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_docs()
        document_id = await create_document(service, title)
        document_url = f"https://docs.google.com/document/d/{document_id}/view"
        elaborated_text = await elaborate_text(text)
        await update_document(service, document_id, elaborated_text)
        return {
            "status": "success",
            "result": {
                "response": "Document created successfully",
                "url": document_url,
            },
        }
    except Exception as e:
        print(f"An error occurred in create_google_doc: {e}")
        return {"status": "failure", "error": str(e)}


async def upload_file_to_folder(
    service, file_path: str, folder_id: Optional[str]
) -> Dict[str, Any]:
    """
    Upload a file to a specified folder in Google Drive and return the file URL.

    Args:
        service: Authenticated Google Drive API service.
        file_path (str): Local path to the file to upload.
        folder_id (Optional[str]): ID of the Google Drive folder to upload to.
                                  If None, the file is uploaded to the root of Google Drive.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and upload details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "File upload successful",
                                 "fileId": str, # ID of the uploaded file
                                 "url": str, # URL to view the uploaded file in Google Drive
                                 "folder_id": str # ID of the folder the file was uploaded to
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        file_metadata = {
            "name": file_path.split("/")[-1],
            "parents": [folder_id] if folder_id else [],
        }
        media = MediaFileUpload(file_path, resumable=True)
        file = (
            service.files()
            .create(body=file_metadata, media_body=media, fields="id")
            .execute()
        )
        file_id = file.get("id")
        file_url = f"https://drive.google.com/file/d/{file_id}/view"
        return {
            "status": "success",
            "result": {
                "response": "File upload successful",
                "fileId": file_id,
                "url": file_url,
                "folder_id": folder_id,
            },
        }
    except HttpError as error:
        print(f"Error uploading file: {error}")
        return {"status": "failure", "error": str(error)}


async def upload_file_to_gdrive(
    file_path: str, folder_name: Optional[str] = None
) -> Dict[str, Any]:
    """
    Search for a folder by name and upload a file to it. If no folder name is provided, upload to root.

    Args:
        file_path (str): Local path to the file to upload.
        folder_name (Optional[str]): Name of the Google Drive folder to upload to (optional).
                                     If provided, the function will search for the folder by name.
                                     If None, the file will be uploaded to the root of Google Drive.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and upload details.
                         Delegates to `upload_file_to_folder` after finding the folder ID (if folder_name is given).
    """
    try:
        service = authenticate_drive()
        folder_id = None

        if folder_name:
            folder_id = await search_folder(service, folder_name)

        result = await upload_file_to_folder(service, file_path, folder_id)
        return result
    except Exception as e:
        print(f"Error in upload_file_to_gdrive: {e}")
        return {"status": "failure", "error": str(e)}


async def search_file(service, query: str) -> str:
    """
    Search for a file in Google Drive by query and return its file ID.

    Args:
        service: Authenticated Google Drive API service.
        query (str): Query string to search for files by name in Google Drive.

    Returns:
        str: The ID of the file if found.
             Raises an exception if no files are found matching the query or if there's an error during search.
    """
    try:
        results = (
            service.files()
            .list(q=f"name contains '{query}'", fields="files(id, name)")
            .execute()
        )
        files = results.get("files", [])
        if not files:
            raise Exception("No files found matching the query.")
        return files[0]["id"]
    except Exception as e:
        raise Exception(f"Error searching for file: {e}")


async def download_file(
    service,
    file_id: str,
    destination: Optional[str] = None,
    export_format: str = "application/pdf",
) -> Dict[str, Any]:
    """
    Download a file from Google Drive using its file ID. Supports exporting Docs Editors files to specified formats.

    Args:
        service: Authenticated Google Drive API service.
        file_id (str): ID of the file to download from Google Drive.
        destination (Optional[str]): Local directory path to save the downloaded file.
                                     If None, defaults to the user's Downloads directory.
        export_format (str): MIME type to export Google Docs, Sheets, or Slides files as (default is "application/pdf").
                             For binary files, this parameter is ignored.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and download details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "File download successful",
                                 "file_name": str, # Name of the downloaded file
                                 "file_id": str, # ID of the downloaded file
                                 "download_path": str # Full path to the downloaded file on the local system
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        if destination is None:
            home_dir = os.path.expanduser("~")
            destination = os.path.join(home_dir, "Downloads")

        if not os.path.exists(destination):
            os.makedirs(destination)

        file_metadata = service.files().get(fileId=file_id).execute()
        file_name = file_metadata["name"]

        file_path = os.path.join(
            destination,
            f"{file_name}.pdf" if export_format == "application/pdf" else file_name,
        )

        if file_metadata["mimeType"].startswith("application/vnd.google-apps"):
            print(f"Exporting '{file_name}' as '{export_format}'")
            request = service.files().export_media(
                fileId=file_id, mimeType=export_format
            )
        else:
            print(f"Downloading binary file '{file_name}'")
            request = service.files().get_media(fileId=file_id)

        with open(file_path, "wb") as f:
            downloader = MediaIoBaseDownload(f, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
                print(f"Download progress: {int(status.progress() * 100)}%")

        return {
            "status": "success",
            "result": {
                "response": "File download successful",
                "file_name": file_name,
                "file_id": file_id,
                "download_path": file_path,
            },
        }

    except HttpError as http_error:
        return {"status": "failure", "error": f"HTTP Error: {http_error}"}
    except Exception as e:
        return {"status": "failure", "error": str(e)}


async def search_and_download_file_from_gdrive(
    file_name: str, destination: str
) -> Dict[str, Any]:
    """
    Search for a file in Google Drive by name and then download it to the specified destination.

    Args:
        file_name (str): Name of the file to search for and download.
        destination (str): Local directory path to save the downloaded file.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and download details.
                         Delegates to `search_file` and `download_file` functions.
    """
    try:
        service = authenticate_drive()
        file_id = await search_file(service, file_name)
        result = await download_file(service, file_id, destination)
        return result
    except Exception as e:
        print(f"Error in search and download: {e}")
        return {"status": "failure", "error": str(e)}


async def create_spreadsheet(service, title: str = "New Spreadsheet") -> Dict[str, Any]:
    """
    Create a new Google Spreadsheet.

    Args:
        service: Authenticated Google Sheets API service.
        title (str): Title of the new spreadsheet (default is "New Spreadsheet").

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and spreadsheet details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Spreadsheet created successfully",
                                 "spreadsheet_url": str # URL to the created Google Spreadsheet
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        spreadsheet = {"properties": {"title": title}}
        request = service.spreadsheets().create(body=spreadsheet)
        response = request.execute()
        return {
            "status": "success",
            "result": {
                "response": "Spreadsheet created successfully",
                "spreadsheet_url": response["spreadsheetUrl"],
            },
        }
    except HttpError as error:
        print(f"Error creating spreadsheet: {error}")
        return {"status": "failure", "error": str(error)}


async def store_data_in_spreadsheet(
    service, spreadsheet_id: str, data: List[List[Any]], range_: str = "Sheet1!A1"
) -> Dict[str, Any]:
    """
    Store data in a Google Spreadsheet, overwriting data in the specified range.

    Args:
        service: Authenticated Google Sheets API service.
        spreadsheet_id (str): ID of the spreadsheet to store data in.
        data (List[List[Any]]): 2D list of data to store in the spreadsheet. Each inner list is a row.
        range_ (str): The range in A1 notation to write data to (default is 'Sheet1!A1').

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and update details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Data stored in spreadsheet",
                                 "updated_cells": int # Number of cells updated
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        if not all(isinstance(row, list) for row in data):
            raise ValueError("Data must be a list of lists.")

        body = {"values": data}
        print(f"Storing data in spreadsheet: {body}")
        result = (
            service.spreadsheets()
            .values()
            .update(
                spreadsheetId=spreadsheet_id,
                range=range_,
                valueInputOption="RAW",
                body=body,
            )
            .execute()
        )

        return {
            "status": "success",
            "result": {
                "response": "Data stored in spreadsheet",
                "updated_cells": result.get("updatedCells"),
            },
        }
    except HttpError as error:
        print(f"Error storing data in spreadsheet: {error}")
        return {"status": "failure", "error": str(error)}


async def append_data_to_spreadsheet(
    service, spreadsheet_id: str, data: List[Any], range_: str = "Sheet1!A1"
) -> Dict[str, Any]:
    """
    Append data to a Google Spreadsheet, adding new rows after existing data in the specified sheet.

    Args:
        service: Authenticated Google Sheets API service.
        spreadsheet_id (str): ID of the spreadsheet to append data to.
        data (List[Any]): List of data to append as a new row.
        range_ (str): The range in A1 notation to start appending from (default is 'Sheet1!A1', but append happens after last row).

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and append details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Data appended in spreadsheet",
                                 "updated_cells": int # Number of cells updated (appended)
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        values = [data] if isinstance(data, list) else [[data]]

        body = {"values": values}
        result = (
            service.spreadsheets()
            .values()
            .append(
                spreadsheetId=spreadsheet_id,
                range=range_,
                valueInputOption="RAW",
                body=body,
            )
            .execute()
        )

        return {
            "status": "success",
            "result": {
                "response": "Data appended in spreadsheet",
                "updated_cells": result.get("updates")["updatedCells"],
            },
        }
    except HttpError as error:
        print(f"Error appending data in spreadsheet: {error}")
        return {"status": "failure", "error": str(error)}


async def read_data_from_spreadsheet(
    service, spreadsheet_id: str, range_: str = "Sheet1!A1"
) -> Dict[str, Any]:
    """
    Read data from a Google Spreadsheet within the specified range.

    Args:
        service: Authenticated Google Sheets API service.
        spreadsheet_id (str): ID of the spreadsheet to read data from.
        range_ (str): The range in A1 notation to read data from (default is 'Sheet1!A1').

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and retrieved data.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Data retrieved successfully",
                                 "values": List[List[Any]] # 2D list of values read from the spreadsheet
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        result = (
            service.spreadsheets()
            .values()
            .get(spreadsheetId=spreadsheet_id, range=range_)
            .execute()
        )

        values = result.get("values", [])
        return {
            "status": "success",
            "result": {"response": "Data retrieved successfully", "values": values},
        }
    except HttpError as error:
        print(f"Error reading data from spreadsheet: {error}")
        return {"status": "failure", "error": str(error)}


async def create_google_sheet(
    data: List[List[Any]], title: str = "New Spreadsheet"
) -> Dict[str, Any]:
    """
    Creates a Google Spreadsheet and populates it with the provided data.

    This function creates a new spreadsheet, gets its ID and URL, and then stores the provided data
    into the first sheet of the newly created spreadsheet.

    Args:
        data (List[List[Any]]): 2D list of data to populate the spreadsheet with.
        title (str): Title of the new Google Spreadsheet (default is "New Spreadsheet").

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and spreadsheet details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Spreadsheet creating successfully with data",
                                 "spreadsheetUrl": str, # URL to the created spreadsheet
                                 "spreadsheet_id": str # ID of the created spreadsheet
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_sheets()
        create_response = await create_spreadsheet(service, title=title)

        if create_response["status"] == "success":
            spreadsheet_url = create_response["result"]["spreadsheet_url"]
            spreadsheet_id = spreadsheet_url.split("/")[-2]

            if not isinstance(data, list) or not all(
                isinstance(row, list) for row in data
            ):
                raise ValueError("Data must be a list of lists (tabular format).")

            store_response = await store_data_in_spreadsheet(
                service, spreadsheet_id, data
            )
            if store_response["status"] == "success":
                return {
                    "status": "success",
                    "result": {
                        "response": "Spreadsheet creating successfully with data",
                        "spreadsheetUrl": spreadsheet_url,
                        "spreadsheet_id": spreadsheet_id,
                    },
                }
            else:
                return {"status": "failure", "error": store_response.get("error")}
        else:
            return {"status": "failure", "error": create_response.get("error")}
    except Exception as e:
        print(f"Error in create_google_sheet: {str(e)}")
        return {"status": "failure", "error": str(e)}


async def create_google_presentation(outline: Dict[str, Any]) -> Dict[str, Any]:
    """
    Creates a Google Slides presentation and populates it with the provided outline.

    This function creates a new presentation, adds a title slide with a title and subtitle,
    and then creates slides based on the outline provided, including titles and content for each slide.

    Args:
        outline (Dict[str, Any]): A dictionary defining the presentation outline, expected to have:
                                     - "topic" (str): Title of the presentation.
                                     - "username" (str): Username to include in the subtitle.
                                     - "slides" (List[Dict]): List of slide dictionaries, each with:
                                         - "title" (str): Title of the slide.
                                         - "content" (List[str]): List of strings for slide content.

    Returns:
        Dict[str, Any]: Status dictionary indicating success or failure and presentation details.
                         On success, returns:
                         {
                             "status": "success",
                             "result": {
                                 "response": "Presentation created successfully",
                                 "presentationUrl": str, # URL to the created presentation
                                 "presentation_id": str # ID of the created presentation
                             }
                         }
                         On failure, returns:
                         {"status": "failure", "error": str(error)}
    """
    try:
        service = authenticate_slides()
        title = outline["topic"]
        user_name = outline["username"]

        create_response = await create_presentation(service, title=title)

        if not create_response:
            raise Exception("Failed to create Google Slides presentation.")

        presentation_id = create_response["presentationId"]
        presentation_url = f"https://docs.google.com/presentation/d/{presentation_id}"

        presentation = (
            service.presentations().get(presentationId=presentation_id).execute()
        )
        default_slide = presentation["slides"][0]

        title_placeholder_id = None
        subtitle_placeholder_id = None

        for element in default_slide.get("pageElements", []):
            if "shape" in element:
                if element["shape"]["shapeType"] == "TEXT_BOX":
                    if title_placeholder_id == None:
                        title_placeholder_id = element["objectId"]
                    else:
                        subtitle_placeholder_id = element["objectId"]

        if title_placeholder_id:
            service.presentations().batchUpdate(
                presentationId=presentation_id,
                body={
                    "requests": [
                        {
                            "insertText": {
                                "objectId": title_placeholder_id,
                                "text": title,
                                "insertionIndex": 0,
                            }
                        }
                    ]
                },
            ).execute()

        if subtitle_placeholder_id:
            service.presentations().batchUpdate(
                presentationId=presentation_id,
                body={
                    "requests": [
                        {
                            "insertText": {
                                "objectId": subtitle_placeholder_id,
                                "text": f"Created by {user_name}",
                                "insertionIndex": 0,
                            }
                        }
                    ]
                },
            ).execute()
        else:
            requests = [
                {
                    "createShape": {
                        "objectId": "SubtitleTextBox",
                        "shapeType": "TEXT_BOX",
                        "elementProperties": {
                            "pageObjectId": default_slide["objectId"],
                            "size": {
                                "width": {"magnitude": 5000000, "unit": "EMU"},
                                "height": {"magnitude": 1000000, "unit": "EMU"},
                            },
                            "transform": {
                                "translateX": 1000000,
                                "translateY": 2000000,
                                "unit": "EMU",
                            },
                        },
                    }
                },
                {
                    "insertText": {
                        "objectId": "SubtitleTextBox",
                        "text": f"Created by {user_name}",
                        "insertionIndex": 0,
                    }
                },
            ]
            service.presentations().batchUpdate(
                presentationId=presentation_id, body={"requests": requests}
            ).execute()

        if (
            not isinstance(outline, dict)
            or "slides" not in outline
            or not isinstance(outline["slides"], list)
        ):
            raise ValueError(
                "Outline must be a dictionary with a 'slides' key containing a list of slides."
            )

        for slide in outline["slides"]:
            slide_title = slide.get("title", "Untitled Slide")
            slide_content = slide.get("content", ["No content provided."])

            if not isinstance(slide_content, list):
                slide_content = [slide_content]

            await create_slide(service, presentation_id, slide_title, slide_content)

        return {
            "status": "success",
            "result": {
                "response": "Presentation created successfully",
                "presentationUrl": presentation_url,
                "presentation_id": presentation_id,
            },
        }
    except Exception as e:
        print(f"Error in create_google_presentation: {e}")
        return {"status": "failure", "error": str(e)}


async def generate_streaming_response(
    runnable, inputs: Dict[str, Any], stream: bool = False
):
    """
    Generic function to generate a streaming response from any runnable.

    This function handles both streaming and non-streaming responses based on the 'stream' parameter
    and whether the runnable supports streaming (has a 'stream_response' method).

    Args:
        runnable: The runnable object (e.g., chain, agent runnable) to invoke.
        inputs (Dict[str, Any]): Input dictionary for the runnable.
        stream (bool): If True, attempt to generate a streaming response if supported by the runnable (default is False).

    Yields:
        AsyncGenerator[Any, None]: Asynchronously yields tokens or the full response depending on streaming.
                                  Yields None if an error occurs during response generation.
    """
    try:
        if stream and hasattr(runnable, "stream_response"):
            for token in await asyncio.to_thread(
                lambda: runnable.stream_response(inputs)
            ):
                yield token
        else:
            response = runnable.invoke(inputs)
            yield response

    except Exception as e:
        print(f"An error occurred: {str(e)}")
        yield None


def generate_response(
    runnable,
    message: str,
    user_context: Optional[str],
    internet_context: Optional[str],
    username: str,
) -> Optional[Dict[str, Any]]:
    """
    Generate a response using the provided runnable, incorporating user and internet context.

    This function invokes the given runnable with a message and context information, retrieves user personality
    description from a user profile database, and passes all these as inputs to the runnable to generate a response.

    Args:
        runnable: The runnable object (e.g., agent runnable) to use for response generation.
        message (str): The user's input message.
        user_context (Optional[str]): Context retrieved from user's personal memory or graph (optional).
        internet_context (Optional[str]): Context retrieved from internet search (optional).
        username (str): The username of the user.

    Returns:
        Optional[Dict[str, Any]]: The response generated by the runnable, or None if an error occurs.
    """
    try:
        with open("../../userProfileDb.json", "r", encoding="utf-8") as f:
            db = json.load(f)

        personality_description = db["userData"].get("personality", "None")

        response = runnable.invoke(
            {
                "query": message,
                "user_context": user_context,
                "internet_context": internet_context,
                "name": username,
                "personality": personality_description,
            }
        )

        return response
    except Exception as e:
        print(f"An error occurred in generating response: {str(e)}")
        return None


def get_chat_history(chat_id: str) -> Optional[List[Dict[str, str]]]:
    """
    Retrieve the chat history for the given chat_id and format it for conversational models.

    This function reads chat history from a JSON database file, filters for the chat with the given ID,
    and formats the last 10 messages into a list of dictionaries suitable for conversational models,
    indicating 'user' or 'assistant' role for each message.

    Args:
        chat_id (str): The unique identifier for the chat session.

    Returns:
        Optional[List[Dict[str, str]]]: Formatted chat history as a list of dictionaries, where each dictionary
                                        has 'role' ('user' or 'assistant') and 'content' (message text).
                                        Returns None if chat history retrieval fails or chat ID is not found.
    """
    try:
        with open("../../chatsDb.json", "r", encoding="utf-8") as f:
            db = json.load(f)

            chats = db.get("chats", [])
            chat = next((c for c in chats if c["id"] == chat_id), None)

            if not chat:
                raise ValueError(f"Chat with id {chat_id} not found.")

            chat_history = chat["chatHistory"][-10:]

            formatted_chat_history: List[Dict[str, str]] = [
                {
                    "role": "user" if entry["isUser"] else "assistant",
                    "content": entry["message"],
                }
                for entry in chat_history
            ]

            return formatted_chat_history

    except Exception as e:
        print(f"Error retrieving chat history: {str(e)}")
        return None
